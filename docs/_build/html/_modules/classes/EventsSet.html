

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>classes.EventsSet &mdash; DYNAPSETools 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="DYNAPSETools 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> DYNAPSETools
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/Dynap-se Net Generator.html">Dynap-se Net Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/Dynap-se Out Decoder.html">Dynap-se Out Decoder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/Dynap-se Spikes Fitter.html">Dynap-se Spikes Fitter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/Dynap-se Spikes Generator.html">Dynap-se Spike Generator</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">DYNAPSETools</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>classes.EventsSet</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for classes.EventsSet</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Contains a class that represent a set of DYNAP-se events</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<div class="viewcode-block" id="EventsSet"><a class="viewcode-back" href="../../scripts/EventsSet.html#classes.EventsSet.EventsSet">[docs]</a><span class="k">class</span> <span class="nc">EventsSet</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A set of DYNAP-se events</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">chip_id</span><span class="p">,</span> <span class="n">core_id</span><span class="p">,</span> <span class="n">neuron_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new EventsSet object</span>

<span class="sd">Parameters:</span>
<span class="sd">    ts (array, float): Times of events</span>
<span class="sd">    chip_id (array, int): Chip number of events</span>
<span class="sd">    core_id (array, int): Core number of events</span>
<span class="sd">    neuron_id (array, int): Neuron number of events</span>

<span class="sd">Note:</span>
<span class="sd">    The event set contains only *normal* events, not *special* ones.</span>

<span class="sd">    Events has the following structure:</span>

<span class="sd">    +------------+------------+-----------+-----------+-----------+ </span>
<span class="sd">    | Vect       | Event 0    |  Event 1  | Event 2   | Event ... |</span>
<span class="sd">    +============+============+===========+===========+===========+ </span>
<span class="sd">    | chip_id    | 0          | 1         | 3         | ...       | </span>
<span class="sd">    +------------+------------+-----------+-----------+-----------+ </span>
<span class="sd">    | core_id    | 0          | 3         | 1         | ...       |</span>
<span class="sd">    +------------+------------+-----------+-----------+-----------+ </span>
<span class="sd">    | neuron_id  | 1          | 100       | 255       | ...       | </span>
<span class="sd">    +------------+------------+-----------+-----------+-----------+</span>
<span class="sd">    | ts         | 150000     | 150064    | 150128    | ...       |</span>
<span class="sd">    +------------+------------+-----------+-----------+-----------+</span>

<span class="sd">    Accessing directly events from an .aedat is very simple, after having imported them::</span>

<span class="sd">        set = import_events(&quot;recording.aedat&quot;) # event set of the recording</span>
<span class="sd">        chip_id = set.chip_id</span>
<span class="sd">        core_id = set.core_id</span>
<span class="sd">        neuron_id = set.neuron_id</span>
<span class="sd">        ts = set.ts</span>

<span class="sd">    We can now access every event::</span>

<span class="sd">        &gt;&gt;&gt; chip_id[0]</span>
<span class="sd">            0</span>
<span class="sd">        &gt;&gt;&gt; core_id[0]</span>
<span class="sd">            0</span>
<span class="sd">        &gt;&gt;&gt; neuron_id[1]</span>
<span class="sd">            100</span>
<span class="sd">        &gt;&gt;&gt; ts[2]</span>
<span class="sd">            150128</span>
<span class="sd">&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span> <span class="o">=</span> <span class="n">chip_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">=</span> <span class="n">core_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span> <span class="o">=</span> <span class="n">neuron_id</span>

<div class="viewcode-block" id="EventsSet.__getitem__"><a class="viewcode-back" href="../../scripts/EventsSet.html#classes.EventsSet.EventsSet.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a time filtered EventsSet object</span>

<span class="sd">Parameters:</span>
<span class="sd">    key (tuple, ints): a tuple containing an init and an end index</span>

<span class="sd">Note:</span>
<span class="sd">    This attribute is very useful when you want to isolate some events for which you know</span>
<span class="sd">    the indexes.</span>

<span class="sd">Example:</span>
<span class="sd">    - Isolate first 10 events::</span>

<span class="sd">        set = import_events(&quot;recording.aedat&quot;) # event set of the recording</span>
<span class="sd">        filteredSet = set[0:10]</span>
<span class="sd">&quot;&quot;&quot;</span>
        <span class="n">init</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">EventsSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">init</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span><span class="p">[</span><span class="n">init</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_id</span><span class="p">[</span><span class="n">init</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span><span class="p">[</span><span class="n">init</span><span class="p">:</span><span class="n">end</span><span class="p">])</span></div>

<span class="c1">### ===========================================================================</span>
<div class="viewcode-block" id="EventsSet.filter_events"><a class="viewcode-back" href="../../scripts/EventsSet.html#classes.EventsSet.EventsSet.filter_events">[docs]</a>    <span class="k">def</span> <span class="nf">filter_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chip_id</span><span class="p">,</span> <span class="n">core_id</span><span class="p">,</span> <span class="n">neuron_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a EventsSet containing only the wanted events</span>

<span class="sd">Parameters:</span>
<span class="sd">    chip_id (int): id of the chip you want to take events from (for now is only possible to filter one chip events)</span>
<span class="sd">    core_id (list, int; int): id of the cores you want to take event from</span>
<span class="sd">    neuron_id (2D list, int; list, int; int): id of the neurons you want to take events from</span>

<span class="sd">Returns:</span>
<span class="sd">    obj EventsSet: A set containing the events resulting from the filtering</span>

<span class="sd">Note:</span>
<span class="sd">    Filter is specified selecting certain chip_id, core_id and neuron_id.</span>
<span class="sd">    It supports only one chip at a time (so chip_id must be a integer from 0 to 3), so you cannot take, for example,</span>
<span class="sd">    events from core 0 of chip 0 and core 1 of chip 1.</span>
<span class="sd">    </span>
<span class="sd">    After selecting the chip_id you have two alternatives: Or don&#39;t apply filters to the cores, by leaving core_id as None.</span>
<span class="sd">    In this way the events of all cores can be potentially taken, **if no neuron_id is specified**. The other alternative is to</span>
<span class="sd">    specify the cores you want to take events from, filtering the ones not specified by you. You can at this point define:</span>

<span class="sd">    1. a single core id, between 0 and 3.</span>
<span class="sd">    2. list of cores id, for example [0, 2].</span>

<span class="sd">    At this point you have two alternatives: Or don&#39;t apply a filter to the neurons inside a core, by neuron_id as None.</span>
<span class="sd">    In this way you will take all the events from the 256 neuron per core (only the one specified in the core filter, of course).</span>
<span class="sd">    The other alternative is to specify the neurons you want to take events from, filtering the ones that are not specified by you.</span>
<span class="sd">    If this is the case, you **must define something for all cores selected in the previous point**. You can define:</span>

<span class="sd">    1. a single neuron id, between 0 and 255</span>
<span class="sd">    2. a list of neurons id, for example [1, 5, 22, 128, ...]</span>

<span class="sd">    The types can be mixed, so you can take a single neuron from one core and a list from another, indipendently.</span>

<span class="sd">Examples:</span>

<span class="sd">    Initialize set importing all events::</span>

<span class="sd">        set = import_events(&quot;recording.aedat&quot;) # event set of the recording</span>
<span class="sd">        </span>
<span class="sd">    - Take events from chip 0, neuron from 0 to 99 of core 0 and neurons from 100 to 199 on core 1::</span>

<span class="sd">        filterCore0 = list(range(0, 100))</span>
<span class="sd">        filterCore1 = list(range(100, 199))</span>
<span class="sd">        neuronIdFilter = [filterCore0, filterCore1]</span>
<span class="sd">        filteredSet = set.filter_events(chip_id = 0,</span>
<span class="sd">                                        core_id = [0, 1],</span>
<span class="sd">                                        neuron_id = neuronIdFilter)</span>
<span class="sd">      </span>
<span class="sd">    - Take all events from chip 1::</span>
<span class="sd">            </span>
<span class="sd">        filteredSet = set.filter_events(chip_id = 1, core_id = None, neuron_id = None)</span>

<span class="sd">    - Take all events from core 0 and 1 of chip 2::</span>

<span class="sd">        filteredSet = set.filter_events(chip_id = 2, core_id = [0, 1], neuron_id = None)</span>

<span class="sd">    - Take only events from neuron 3 of core 0 and chip 3::</span>

<span class="sd">        filteredSet = set.filter_events(chip_id = 3, core_id = 0, neuron_id = 3)</span>

<span class="sd">    - Take events from chip 0, neuron 20 of core 0 and neuron 127 of core 1::</span>

<span class="sd">        filteredSet = set.filter_events(chip_id = 0, core_id = [0, 1], neuron_id = [20, 127])</span>
<span class="sd">&quot;&quot;&quot;</span>
        
        <span class="c1">#Check the core_id input to find events correlated with it*/</span>
        <span class="n">filter_core_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span> <span class="c1"># Initialization to all false</span>
        <span class="k">try</span><span class="p">:</span> <span class="c1"># If &#39;for&#39; not fails -&gt; multiple cores</span>
            <span class="k">for</span> <span class="n">current_id</span> <span class="ow">in</span> <span class="n">core_id</span><span class="p">:</span> <span class="c1"># Take events for all the cores</span>
                <span class="n">filter_core_id</span> <span class="o">=</span> <span class="n">filter_core_id</span> <span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">current_id</span><span class="p">)</span> 
        <span class="k">except</span><span class="p">:</span> <span class="c1"># If &#39;for&#39; fails -&gt; single core</span>
            <span class="n">filter_core_id</span> <span class="o">=</span> <span class="n">filter_core_id</span> <span class="o">|</span> <span class="p">(</span><span class="n">core_id</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span><span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">core_id</span><span class="p">)</span> <span class="c1"># Take events only for a certain core</span>
        
        <span class="c1"># Check the neuron_id input to find events correlated with it*/    </span>
        <span class="n">filter_neuron_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">)</span> <span class="c1"># Initialization to all false</span>
        <span class="k">try</span><span class="p">:</span> <span class="c1"># If &#39;for&#39; not fails -&gt; multiple lists (or just one)</span>
            <span class="k">for</span> <span class="n">core_index</span><span class="p">,</span> <span class="n">neuron_list</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neuron_id</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span> <span class="c1"># If &#39;for&#39; not fails -&gt; multiple neurons</span>
                    <span class="k">for</span> <span class="n">current_id</span> <span class="ow">in</span> <span class="n">neuron_list</span><span class="p">:</span> <span class="c1"># Take events only for a certain neuron and a certain core</span>
                        <span class="n">filter_neuron_id</span> <span class="o">=</span> <span class="n">filter_neuron_id</span> <span class="o">|</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">core_id</span><span class="p">[</span><span class="n">core_index</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span> <span class="o">==</span> <span class="n">current_id</span><span class="p">))</span>
                <span class="k">except</span><span class="p">:</span> <span class="c1"># If &#39;for&#39; fails -&gt; single neuron</span>
                    <span class="k">try</span><span class="p">:</span> <span class="c1"># If it not fails means that core_id is a list, so we have a list of single neurons</span>
                        <span class="n">filter_neuron_id</span> <span class="o">=</span> <span class="n">filter_neuron_id</span> <span class="o">|</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">core_id</span><span class="p">[</span><span class="n">core_index</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">neuron_list</span> <span class="o">==</span> <span class="kc">None</span><span class="p">))</span>
                        <span class="n">filter_neuron_id</span> <span class="o">=</span> <span class="n">filter_neuron_id</span> <span class="o">|</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">core_id</span><span class="p">[</span><span class="n">core_index</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span> <span class="o">==</span> <span class="n">neuron_list</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span> <span class="c1"># If it fails means that core_id is a number, so we have a single list of neurons</span>
                        <span class="n">filter_neuron_id</span> <span class="o">=</span> <span class="n">filter_neuron_id</span> <span class="o">|</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">core_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span> <span class="o">==</span> <span class="n">neuron_list</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">filter_neuron_id</span> <span class="o">=</span> <span class="n">filter_neuron_id</span> <span class="o">|</span> <span class="p">(</span><span class="n">neuron_id</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span><span class="o">|</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span> <span class="o">==</span> <span class="n">neuron_id</span><span class="p">)</span>
            
        <span class="c1"># Combine all filters and apply them, getting only the events that has been selected*/    </span>
        <span class="n">indx_neurons</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span> <span class="o">==</span> <span class="n">chip_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">filter_core_id</span> <span class="o">&amp;</span> <span class="n">filter_neuron_id</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">EventsSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">indx_neurons</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span><span class="p">[</span><span class="n">indx_neurons</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_id</span><span class="p">[</span><span class="n">indx_neurons</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span><span class="p">[</span><span class="n">indx_neurons</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">errorString</span> <span class="o">=</span> <span class="s2">&quot;Error while filtering neuron events, no spikes found, check the constrains&quot;</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">errorString</span><span class="p">)</span></div>

<span class="c1">### ===========================================================================</span>
<div class="viewcode-block" id="EventsSet.isolate_events_sets"><a class="viewcode-back" href="../../scripts/EventsSet.html#classes.EventsSet.EventsSet.isolate_events_sets">[docs]</a>    <span class="k">def</span> <span class="nf">isolate_events_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startTriggerNeuron</span><span class="p">,</span> <span class="n">stopTriggerNeuron</span><span class="p">,</span> <span class="n">maxNumber</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of Event sets each one containing an experiment.</span>

<span class="sd">Parameters:</span>
<span class="sd">    startTriggerNeuron (tuple, int (chip id, core id, neuron id)): Neuron which events triggers the start of the experiment</span>
<span class="sd">    stopTriggerNeuron (tuple, int (chip id, core id, neuron id)). Neuron which events trigger the end of the experiment</span>
<span class="sd">    maxNumber (int): max number of experiments that can be extracted from the Set of events</span>

<span class="sd">Returns:</span>
<span class="sd">    list, obj EventsSet: a list of Event sets each one containing an experiment</span>

<span class="sd">Note:</span>
<span class="sd">    When dealing with Dynap-se output recordings, one of the main problems is &quot;how get only events that are associated only with my input?&quot;</span>
<span class="sd">    You can, of course, filter events manually using custom functions, but this is expensive in terms of time.</span>
<span class="sd">    An automatic solution, however, can be to use two Dynap-se neurons to trigger the start and the end of the events correlated to my input.</span>

<span class="sd">    The experiment would be constructed in this way:</span>

<span class="sd">    1. send a spike to a neuron that will represent my starting trigger</span>
<span class="sd">    2. send the experiment input spikes after small delay, negligible with respect to the delays involved in the input stream</span>
<span class="sd">    3. send a spike to a neuron that will represent my ending trigger, with a small delay, as for the input</span>

<span class="sd">    So each experiment is the repetition of these 3 passages. Make sure there is enough delay between the stop trigger event and the</span>
<span class="sd">    start of the new one. You should avoid overlapping of them, because this can create confusion while extracting events.</span>
<span class="sd">    The code is able to handle multiple spikes of start and trigger neurons for the same experiment, so don&#39;t much worry about that.</span>

<span class="sd">    This function should be applied to the output recording in order to filter all events but for the ones that are between</span>
<span class="sd">    the start and stop neurons. In this way you can automatically synchronize your analysis with the events generated only by your input.</span>
<span class="sd">    </span>
<span class="sd">    It is possible to specify also a maximum number of experiments that are extracted from the set using maxNumber parameter.</span>

<span class="sd">Examples:</span>
<span class="sd">    ::</span>
<span class="sd">        </span>
<span class="sd">        # Initialize set importing all events</span>
<span class="sd">        set = import_events(&quot;recording.aedat&quot;) # event set of the recording</span>

<span class="sd">    - startTriggerNeuron neuron 64 of core 2 of chip 0, stopTriggerNeuron is neuron 128 of core 2 of chip 0. Take all experiments (no maxNumber specified) included between these two neurons::</span>
<span class="sd">        </span>
<span class="sd">        startTriggerNeuron = (0, 2, 64)</span>
<span class="sd">        stopTriggerNeuron = (0, 2, 128)</span>
<span class="sd">        extractedEvents = set.isolate_events_sets(startTriggerNeuron = startTriggerNeuron,</span>
<span class="sd">                                                  stopTriggerNeuron = stopTriggerNeuron,</span>
<span class="sd">                                                  maxNumber = None)</span>

<span class="sd">    - startTriggerNeuron neuron 64 of core 2 of chip 0, stopTriggerNeuron neuron 128 of core 2 of chip 0. Take UP TO 5 experiments between these two neurons::</span>

<span class="sd">        startTriggerNeuron = (0, 2, 64)</span>
<span class="sd">        stopTriggerNeuron = (0, 2, 128)</span>
<span class="sd">        extractedEvents = set.isolate_events_sets(startTriggerNeuron = startTriggerNeuron,</span>
<span class="sd">                                                  stopTriggerNeuron = stopTriggerNeuron,</span>
<span class="sd">                                                  maxNumber = 5)</span>
<span class="sd">&quot;&quot;&quot;</span>
        
        <span class="c1"># If absolute index, convert to tuple containing (core, neuron id)</span>
        <span class="c1">#if not isinstance(startTriggerNeuron, collections.Iterable):</span>
        <span class="c1">#    startTriggerCore = (int) (startTriggerNeuron / 256)</span>
        <span class="c1">#    startTriggerNeuron = (startTriggerCore, startTriggerNeuron % (256 * startTriggerCore))</span>
        <span class="c1">#if not isinstance(stopTriggerNeuron, collections.Iterable):</span>
        <span class="c1">#    stopTriggerCore = (int) (stopTriggerNeuron / 256)</span>
        <span class="c1">#    stopTriggerNeuron = (stopTriggerCore, stopTriggerNeuron % (256 * stopTriggerCore))</span>
        
        <span class="c1"># Find the index of the start trigger neurons or stop trigger neurons</span>
        <span class="n">startTriggerIndexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span> <span class="o">==</span> <span class="n">startTriggerNeuron</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
                                       <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">startTriggerNeuron</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                                       <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span> <span class="o">==</span> <span class="n">startTriggerNeuron</span><span class="p">[</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stopTriggerIndexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span> <span class="o">==</span> <span class="n">stopTriggerNeuron</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span>
                                      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">stopTriggerNeuron</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                                      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span> <span class="o">==</span> <span class="n">stopTriggerNeuron</span><span class="p">[</span><span class="mi">2</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Setup experiment list</span>
        <span class="n">experiments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Sweep over all requested experiments number</span>
        <span class="n">startTrigger</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">stopTrigger</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Initialize the number of experiments to be taken</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">maxNumber</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">maxNumber</span>

        <span class="k">while</span> <span class="p">((</span><span class="n">maxNumber</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Calculate the start and stop trigger of the current experiment</span>
                <span class="n">startTrigger</span> <span class="o">=</span> <span class="n">startTriggerIndexes</span><span class="p">[</span><span class="n">startTriggerIndexes</span> <span class="o">&gt;=</span> <span class="n">stopTrigger</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Start trigger should happen after the previous end trigger</span>
                <span class="n">stopTrigger</span> <span class="o">=</span> <span class="n">stopTriggerIndexes</span><span class="p">[</span><span class="n">stopTriggerIndexes</span> <span class="o">&gt;=</span> <span class="n">startTrigger</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># End trigger should happen after start trigger</span>

                <span class="c1"># Filter the spikes information according to the previous range (the +1 is in order to take also the trigger spike)</span>
                <span class="c1"># Start and stop trigger are included!</span>
                <span class="n">ts_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">startTrigger</span><span class="p">:(</span><span class="n">stopTrigger</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">neuron_id_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span><span class="p">[</span><span class="n">startTrigger</span><span class="p">:(</span><span class="n">stopTrigger</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">core_id_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_id</span><span class="p">[</span><span class="n">startTrigger</span><span class="p">:(</span><span class="n">stopTrigger</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">chip_id_event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span><span class="p">[</span><span class="n">startTrigger</span><span class="p">:(</span><span class="n">stopTrigger</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

                <span class="c1"># Append experiment and increment counter</span>
                <span class="n">experiments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">EventsSet</span><span class="p">(</span><span class="n">ts_event</span><span class="p">,</span> <span class="n">chip_id_event</span><span class="p">,</span> <span class="n">core_id_event</span><span class="p">,</span> <span class="n">neuron_id_event</span><span class="p">))</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">break</span><span class="p">;</span>

        <span class="c1"># Check if there are experiments in the list</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">errorString</span> <span class="o">=</span> <span class="s2">&quot;Error while extracting experiments, cannot find any valid one: &quot;</span>
            <span class="n">errorString</span> <span class="o">+=</span> <span class="s2">&quot;Check start and stop trigger neurons, or maxNumber value&quot;</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="n">errorString</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Extracted </span><span class="si">{}</span><span class="s2"> experiments&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">experiments</span></div>

<span class="c1">### ===========================================================================</span>
<div class="viewcode-block" id="EventsSet.plot_events"><a class="viewcode-back" href="../../scripts/EventsSet.html#classes.EventsSet.EventsSet.plot_events">[docs]</a>    <span class="k">def</span> <span class="nf">plot_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raster plot of events included in the current EventsSet</span>

<span class="sd">Parameters:</span>
<span class="sd">    ax (ax handle, optional): Plot graph on this handle, otherwise a new figure will be created</span>

<span class="sd">Returns:</span>
<span class="sd">    (tuple): tuple containing:</span>
<span class="sd">        </span>
<span class="sd">        - **fig** (*fig handles*): To modify properties of the figure</span>
<span class="sd">        - **ax** (*ax handles*): To modify properties of the plot</span>
<span class="sd">        - **handles** (*lines handles*): To create custom legends</span>

<span class="sd">Note:</span>
<span class="sd">    Colors has been chosen to be clearly visible and to match the DYNAP-se core color enconding::</span>

<span class="sd">        - core 0: green</span>
<span class="sd">        - core 1: magenta</span>
<span class="sd">        - core 2: red</span>
<span class="sd">        - core 3: yellow</span>

<span class="sd">    With this classification there there is no distinguish between different chips events. It is much better</span>
<span class="sd">    to filter them and display them separately.</span>

<span class="sd">    The input ax value can be used to make it plot over a pre-created figure. Fig, ax and handles can be used instead</span>
<span class="sd">    by the user to specify in detail the properties of the graph (see Example for how to do it)</span>

<span class="sd">Examples:</span>
<span class="sd">    ::</span>

<span class="sd">        # Initialize set importing all events</span>
<span class="sd">        set = import_events(&quot;recording.aedat&quot;) # event set of the recording</span>
<span class="sd">        figList, ax, handles = set.plot_events() # plot events</span>
<span class="sd">        ax.set_title(&quot;Raster plot Recording&quot;)</span>
<span class="sd">        ax.set_xlabel(&#39;time [us]&#39;)</span>
<span class="sd">        ax.set_ylabel(&#39;Neuron id&#39;)</span>
<span class="sd">&quot;&quot;&quot;</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If no subplot is specified, create new plot</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Plot different cores with different colors</span>
        <span class="k">for</span> <span class="n">core</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">indx_core</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">==</span> <span class="n">core</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Search for events of a core</span>
            
            <span class="k">if</span> <span class="n">core</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>
            <span class="k">elif</span> <span class="n">core</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
            <span class="k">elif</span> <span class="n">core</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span>
                
            <span class="n">handle</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="n">indx_core</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span><span class="p">[</span><span class="n">indx_core</span><span class="p">]</span> <span class="o">+</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">core</span><span class="p">,</span> <span class="n">linestyle</span> <span class="o">=</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">handles</span></div>

<span class="c1">### ===========================================================================</span>
<div class="viewcode-block" id="EventsSet.calculate_firing_rate_matrix"><a class="viewcode-back" href="../../scripts/EventsSet.html#classes.EventsSet.EventsSet.calculate_firing_rate_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_firing_rate_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">totNeurons</span><span class="p">,</span> <span class="n">numBins</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">timeBin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derive a firing rate matrix starting from the current EventSet</span>
<span class="sd">        </span>
<span class="sd">Parameters:</span>
<span class="sd">    totNeurons (int): Maximum number of neurons for which firing rate is calculated (from id = 0 to totNeuron number)</span>
<span class="sd">    numBins (int): Default parameter. Number of intervals in which firing rate must be evaluated</span>
<span class="sd">    tBin (int, [s], optional): Amplitude of each interval in which firing rate must be evaluated</span>

<span class="sd">Returns:</span>
<span class="sd">    (tuple): tuple containing:</span>

<span class="sd">        - **timeSteps** (*array, float*): Time steps in which firing rate has been calculated</span>
<span class="sd">        - **neuronsFireRate** (*2D array, float*): Contain firing rate for every neuron and for every time step</span>

<span class="sd">Note:</span>
<span class="sd">    To evaluate the firing rate the average of the spikes is made over a certain time step. The rate value is then associated</span>
<span class="sd">    to the first time in the time bin, as here below::</span>

<span class="sd">        timeSteps -&gt; [t0 t0+tBin t0+2tBin ... tn-tBin]</span>
<span class="sd">    </span>
<span class="sd">    where tBin is the temporal step in which firing rate is evaluated (tBin = (tn - t0) / numBins)) or directly the specified tBin</span>

<span class="sd">    The firing rate is calculated for every specified neuron, obtaining the following matrix (number are expressed in Hz):</span>

<span class="sd">    +------------+--------------+----------------+---------------+----------------+</span>
<span class="sd">    | neuron id  | fr at t0     | fr at t0+tBin  | ...           | fr at t0+ntBin |</span>
<span class="sd">    +============+==============+================+===============+================+</span>
<span class="sd">    | neuron 0   | 5            | 0              | ...           | 0              |</span>
<span class="sd">    +------------+--------------+----------------+---------------+----------------+</span>
<span class="sd">    | neuron 1   | 0            | 10             | ...           | 10             |</span>
<span class="sd">    +------------+--------------+----------------+---------------+----------------+</span>
<span class="sd">    | ...        | 2            | 2              | ...           | 2              |</span>
<span class="sd">    +------------+--------------+----------------+---------------+----------------+</span>
<span class="sd">    | neuron n   | 20           | 10             | ...           | 10             |</span>
<span class="sd">    +------------+--------------+----------------+---------------+----------------+</span>

<span class="sd">Examples:</span>
<span class="sd">    ::</span>

<span class="sd">        # Initialize set importing all events</span>
<span class="sd">        set = import_events(&quot;recording.aedat&quot;) # event set of the recording</span>

<span class="sd">        # obtain firing rate from number of bins</span>
<span class="sd">        timeSteps, neuronsFireRate = set.calculate_firing_rate_matrix(totNeurons = 1024,</span>
<span class="sd">                                                                      numBins = 100)</span>
<span class="sd">        </span>
<span class="sd">        # obtain firing rate from bin size</span>
<span class="sd">        timeSteps, neuronsFireRate = set.calculate_firing_rate_matrix(totNeurons = 1024,</span>
<span class="sd">                                                                      timeBin = 0.02)</span>
<span class="sd">&quot;&quot;&quot;</span>
        
        <span class="c1"># Initialize vectors</span>
        <span class="n">timeSteps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#neuronSpikes = [[] for count in np.arange(totNeurons)]</span>
        <span class="n">neuronsFireRate</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">totNeurons</span><span class="p">)]</span>
        <span class="n">absoluteNeurons</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">core_id</span> <span class="o">*</span> <span class="mi">256</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span>

        <span class="c1"># Calculate time bins</span>
        <span class="k">if</span> <span class="n">timeBin</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># If time bin is fixed and the number of bins are variable</span>
            <span class="n">binSize</span> <span class="o">=</span> <span class="n">timeBin</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="c1"># Transform in [us]</span>
            <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">timeBins</span> <span class="o">=</span> <span class="p">[</span><span class="n">time</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">time</span> <span class="o">+=</span> <span class="n">binSize</span>
                <span class="n">timeBins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># If time bin is variable and the number of bins are fixed</span>
            <span class="n">timeBins</span><span class="p">,</span> <span class="n">binSize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">numBins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">retstep</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">timeBins</span> <span class="o">=</span> <span class="p">[(</span><span class="n">timeBins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">timeBins</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">timeBins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        
        <span class="c1"># Sweep over the time bins and calculate spikes and firing rate</span>
        <span class="k">for</span> <span class="n">timeBin</span> <span class="ow">in</span> <span class="n">timeBins</span><span class="p">:</span>
            <span class="n">timeSteps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">timeBin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Initialize to 0 the firing rate of all neurons</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">totNeurons</span><span class="p">):</span> 
                <span class="c1">#neuronSpikes[pos].append(0)</span>
                <span class="n">neuronsFireRate</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Find the spikes in the time Bin</span>
            <span class="n">spanInterval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">&gt;=</span> <span class="n">timeBin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">&lt;</span> <span class="n">timeBin</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Span the spikes and increment the spike counter in the neuron list</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">spanInterval</span><span class="p">:</span>
                <span class="c1">#neuronSpikes[absoluteNeurons[pos]][-1] += 1</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">neuronsFireRate</span><span class="p">[</span><span class="n">absoluteNeurons</span><span class="p">[</span><span class="n">pos</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">totNeurons</span><span class="p">):</span> <span class="c1"># Do the average in all neurons</span>
                <span class="c1">#neuronFireRate[pos][-1] = neuronSpikes[pos][-1] / (binSize / 1e6)</span>
                <span class="n">neuronsFireRate</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuronsFireRate</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">binSize</span> <span class="o">/</span> <span class="mf">1e6</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">timeSteps</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neuronsFireRate</span><span class="p">)</span></div>

<span class="c1">### ===========================================================================</span>
<div class="viewcode-block" id="EventsSet.normalize"><a class="viewcode-back" href="../../scripts/EventsSet.html#classes.EventsSet.EventsSet.normalize">[docs]</a>    <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Normalize the time of the current EventSet</span>

<span class="sd">Returns:</span>
<span class="sd">    obj EventsSet: A new normalized EventSet</span>

<span class="sd">Note:</span>
<span class="sd">    The time of the first event is set to 0. The subsequent are changed accordingly</span>
<span class="sd">&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">EventsSet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chip_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neuron_id</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Cattaneo Roberto.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>